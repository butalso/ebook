# redis篇

## 什么是redis
Redis(Remote Dictionary Server)是一个使用C语言编写，开源（BSD许可）的高性能非关系型（NOSQL）键值对数据库。\
Redis可以存储键和五种不同类型的值之间的映射，键的类型只能是字符串，值的类型可为：字符串、列表、哈希、集合、有序集合。\
与传统数据库不同的是，Redis中的数据是存在内存中的，因此，读写速度非常快。也正因为如此，redis被广泛用来做数据缓存。另外，Redis也经常用来做分布式锁。除此之外，Redis还支持事务、持久化、LUA脚本，集群。

## Redis优缺点
优点
* 性能高，能支持每秒超过100K的读写频率
* 数据结构丰富，支持 字符创、列表、哈希、集合、有序集合五种对象，同时，封装的SDS数据结构是二进制安全的
* 支持事务，Redis的所有操作都是原子性的
* 支持数据持久化，可采用AOF、RDB两种持久化方式
* 其他特性： publish/subscribe，lua脚本等

缺点
* 由于是内存数据库，所以，单台机器，存储的数据量受到机器本身内存大小限制。虽然redis本身有key过期策略和内存淘汰策略，但是还是需要提前预估和节约内存。如果内存增长过快，最好定期删除数据\
过期策略：定时删除、惰性删除、定期删除\
内存淘汰：内存不足时，淘汰其他数据来处理新写入的数据。（可能是报错，或移除最少使用的key等等）
  
## Redis为什么这么快
* 纯内存操作，不需要进行磁盘IO
* C语言实现，接近底层操作
* 高效的数据结构，同种对象在不同场景下都有可能用到不同数据结构，比如列表（压缩列表，链表），有序集合（压缩列表，跳表）
* 单线程的IO多路复用模型(6.0以前），单线程避免不必要上下文切换、抢锁，同时IO多路复用可以高效的处理多个网络连接请求。

## Redis 6.0为什么又引入了多线程

### 采用单线程
* IO多路复用，可同时监听多个网络请求
* 对于Redis来说，基于内存的操作速度相当快，能够达到1秒处理100K个用户请求的并发。同时，如果100K的并发了还不能满足，可以采用Redis分片技术将请求交给不同的Redis服务器处理。
* 多线程模型虽然在某些方面表现优异，但是同时引入程序执行顺序的不确定性，不方便调试测试。

### 多线程
* Redis的多线程部分主要用来处理网络数据读写和协议解析，执行命令依然主要是单线程。
* 对一些大键值对的删除操作，增加了多线程命令，比如FLUSHDB ASYNC。

## IO多路复用
### 阻塞IO
对于阻塞的IO来说，当调用read、write执行操作时，如果数据还没准备好，那么该线程就会被挂起，直到数据准备好。\
对于服务器来说，假如它需要处理1000个连接，但这1000个连接又只有很少连接是忙碌的，则这1000个线程大部分时间是处于阻塞状态的。由于CPU的核数或超线程数一般较小，那么每个线程分配得到的时间片也就比较少，线程切换频繁。这样子是有问题的
* 线程是有内存开销的，1个线程可能需要512K存放栈，那么1000个线程就需要512M内存。
* 线程切换是需要消耗CPU时间的。当大量时间花在上下文切换的时候，分配给真正的操作的CPU时间就要少很多。

### IO多路复用（事件驱动）
多路复用在通信上指的是在一个信道上传输多路信号或数据流的技术。\
IO多路复用指的是通过某种机制，监听多个文件描述符（socket)，当其中任意一个文件描述符处于就绪状态时，能够通知程序进行相应的读写操作。

### 同步、异步、阻塞、非阻塞
#### 同步&异步
同步和异步关注的是**消息通信机制**，所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。而异步则是在调用发出后，调用直接就返回了。
#### 阻塞&非阻塞
阻塞和非阻塞关注的是程序在等待调用结果时的状态。阻塞指在调用结果返回前，当前线程会被挂起，调用线程只有得到结果之后才会返回。非阻塞指在不能立刻得到结果之前，该调用不会阻塞当前线程。\
以小明下载文件为例：
* 同步阻塞：小明一直盯着下载进度条，知道100%下载完成
* 同步非阻塞：小明点击下载后就玩手机去了，不过每隔一段时间会过来check下载是否完成
* 异步阻塞：小明有个下载完成通知的软件，在下载完成后会“叮”的一声通知小明下载完成，不过小明一直傻傻的等待“叮”的声音
* 异步非阻塞：仍然是那个下载完成会“叮”的一声通知的软件，不过小明提交下载任务后就去做别的事情去了，当听到“叮”的声音就知道下载完成了。

## 缓存
### 作用（高性能和高并发）
* 最大程度避免对数据库的并发查询，从而降低因为数据库资源不足导致的新系统故障
* 提升速度响应速度，保证用户体验
* 如果系统使用到了数据库，但是没使用缓存，如果网站有很高的访问量，那么网站的可用状态极有可能是断断续续的。
### 分布式缓存 VS 本地缓存
#### 分布式缓存（redis，memcached）
* 分布式缓存用于集群环境下多节点使用同一份缓存的情况，从而减少数据库查询
* 分布式缓存有网络IO，因此，吞吐率与缓存数据大小有较大关系
* 分布式缓存网络IO导致的时间消耗不可忽略

#### 本地缓存 map
* 本地缓存非常高效，从分布式缓存取一次数据消耗的时间可以从本地缓存取几千几万甚至百万次
* 本地缓存在集群环境下存在不同节点数据不一致问题，因此，使用时需要考虑缓存的时效性，以及缓存数据对不一致的敏感程度

#### 缓存时效性
* 不同场景对同一份数据的时效性有差异，比如商品库存，在页面展示是否可以购买时可以有短暂的缓存，但是订单提交时必须是实时的数据
* 不同数据时效性不一样，比如商品属性时效性要求较低，商品价格和库存的时效性要求就比较高。

#### 本地缓存+分布式缓存构建高性能网站
* 使用本地缓存做一级缓存，减少分布式缓存的访问量（网络IO带宽消耗和IO传输时间）
* 使用分布式缓存做二级缓存，减少集群环境下访问数据库的次数




