# MySQL篇

## 数据库基础知识
### 使用数据库系统的好处
1. 数据库系统中数据的共享性高，大大减少数据冗余，节约存储空间，避免数据之间的不相容性与不一致性，使得数据库系统弹性大，易于扩充。
2. 数据库系统的数据独立性高，把数据的定义从程序中分离出去，而存取数据的方法又由数据库管理系统负责提供，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。
3. 数据库管理系统提供了数据的安全性保护、数据的完整性检查、并发控制、数据库恢复等数据控制功能，保证了数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。

### SQL语句分类
DQL、DDL、DML、DCL

### 超键、候选键主键、外键
* 超键(super key):在关系中能唯一标识元组的属性集称为关系模式的超键
* 候选键(candidate key):不含有多余属性的超键称为候选键
* 主键(primary key):用户选作元组标识的一个候选键程序主键
* 外键(foreign key)如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。

### SQL约束有哪几种
primary key、unqiue key、foreign key、default、not null、 check

### 数据库三大范式
1. 第一范式(确保每列保持原子性): 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。
2. 第二范式(确保表中的每列都和主键相关): 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中
3. 第三范式(确保每列都和主键列直接相关,而不是间接相关): 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

### MySQL的binlog形式
* statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
* row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
* mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。

### MySQL的几种日志文件
* 错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
* 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
* 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
* 二进制日志：记录对数据库执行更改的所有操作。
* 中继日志：中继日志也是二进制日志，在主从复制中，从服务器将来自主服务器的二进制日志保存为中继日志，在主从复制中起到缓冲的作用。
* 事务日志：重做日志redo和回滚日志undo


### drop、delete、truncate的区别
* 从类型上看， drop、truncate属于DDL，delete属于DML，因此，drop、truncate不可回滚，delete可回滚
* 从删除内容上看，drop会删掉该表的所有数据，包括表结构、表数据、表索引、权限；truncate只会删除表中全部数据；delete只会删除表中部分或全部数据
* 从执行速度上看，drop > truncate > delete

1，innodb下，count(1) count(*) count(主键id)  count(非主键索引id)  效率排序
2，一条简单查询语句在mysql中是怎么执行的
3，一条update语句在mysql中怎么执行的
4，一个排序的查询语句在mysql中怎么执行的
5，mysql如何选的索引

## 存储引擎
### MySQL存储引擎InnoDB和MyISAM的比较
1. `InnoDB`支持事务，MyISAM不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此`InnoDB`必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而`MyISAM`是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    
5. InnoDB最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是`MySQL`将默认存储引擎从 MyISAM变成InnoDB的重要原因之一；

### 如何判断选择InnoDB还是MySIAM
1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；
2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。
3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB； 
4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。

### InnoDB引擎的特性
#### 插入缓冲
对于非聚集索引的插入或更新操作， 不是每一次直接插入到索引页中， 而是先判断插入的非聚集索引页是否在缓冲池中， 若在， 则直接插入； 若不在， 则先放入到一个Insert Buffer对象中， 好似欺骗。 数据库这个非聚集的索引已经插到叶子节点， 而实际并没有， 只是存放在另一个位置。 然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并） 操作， 这时通常能将多个插入合并到一个操作中（因为在一个索引页中）， 这就大大提高了对于非聚集索引插入的性能。

###### 插入缓冲需要同时满足以下两个条件：
* 索引是辅助索引（secondary index）
* 索引不是唯一（unique）的，如果是唯一的，需要校验唯一性，如果去查找就会发生随机读，失去插入缓冲的意义

##### 插入缓冲问题：
* 大量使用插入缓冲，如果MySQL宕机，恢复可能需要较长的时间
* 写密集情况下，占用过多内存

#### 两次写
* 两次写应用在当页发生部分写失效时，使用页的副本先还原该页，然后通过重做日志进行重做。
* doublewrite由两部分组成， 一部分是内存中的doublewrite buffer， 大小为2MB， 另一部分是物理磁盘上共享表空间中连续的128个页， 即2个区（extent）， 大小同样为2MB。 在对缓冲池的脏页进行刷新时， 并不直接写磁盘， 而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次， 每次1MB顺序地写入共享表空间的物理磁盘上， 然后马上调用fsync函数， 同步磁盘， 避免缓冲写带来的问题。 在这个过程中， 因为doublewrite页是连续的， 因此这个过程是顺序写的， 开销并不是很大。 在完成doublewrite页的写入后， 再将doublewrite buffer中的页写入各个表空间文件中， 此时的写入则是离散的

#### 自适应哈希索引
* 哈希（hash） 是一种非常快的查找方法， 在一般情况下这种查找的时间复杂度为O(1)， 即一般仅需要一次查找就能定位数据。 而B+树的查找次数， 取决于B+树的高度， 在生产环境中， B+树的高度一般为3～4层， 故需要3～4次的查询。
* AHI是通过缓冲池的B+树页构造而来， 因此建立的速度很快， 而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问频率和模式来自动地为某些热点页建立哈希索引。
* AHI有一个要求， 即对这个页的连续访问模式必须是一样的哈希索引只能用来搜索等值的查询， 而对于其他查找类型， 如范围查找， 是不能使用哈希索引的，

#### 异步IO
#### 刷新邻接页
当刷新一个脏页时， InnoDB存储引擎会检测该页所在区（extent） 的所有页， 如果是脏页， 那么一起进行刷新。 通过AIO可以将多个IO写入操作合并为一个IO操作

## 表
### 什么是视图，物化视图，使用视图的优缺点
### MySQL如何实现物化视图
### 什么是存储过程，存储过程的优缺点

## 索引
### 索引的基本原理
索引的目的在于提高查询效率，可以类比字典，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

### 索引算法有哪些
#### B+树索引

#### 哈希索引


### InnoDB索引设计原则
1. 尽量选择区分度高的列作为索引
2. 选择唯一性索引： 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。
3. 为经常需要排序、分组和联合操作的字段建立索引: 经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。
4. 为常作为查询条件的字段建立索引: 如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。
5. 限制索引的数目: 索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。
6. 尽量使用数据量少的索引: 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多。
7. 尽量使用前缀来索引: 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。
8. 删除不再使用或者很少使用的索引: 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

### 使用索引查询一定能提高性能吗
使用索引不一定会提高性能，考虑一下两种点：
1. 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改，这就降低了数据的增删改速度。
2. 当进行一个范围查找时，如果返回结果集占整个数据集较大一部分时，一般是20%左右， 如果采用索引，将会进行大量随机IO，这时候，优化器一般也会采用全表扫描。

## 锁
### MySQL有几种锁类型
### 什么是死锁？怎么解决
### 锁与事务隔离级别的关系，不同隔离级别会出现什么问题

## 事务
### 什么是事务
### 事务的四大特性
### MySQL事务实现机制

## SQL优化

## 数据库优化
### 复制的原理

## 参考链接
* <https://juejin.im/post/5cb6c4ef51882532b70e6ff0>
* <https://blog.csdn.net/ThinkWon/article/details/104778621>
* <https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html>
* <https://www.zhihu.com/question/20596402>
