## 缓存

### 什么是缓存
缓存一词最开始用于CPU和主内存之间，原始意义是指访问速度比一般随机存取存储器(RAM)快的一种RAM。现如今，凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输差异的结构，均可称为缓存。比如在内存和硬盘之间的磁盘缓存，硬盘与网络之间Internet临时文件夹或网络内容缓存。在互联网行业，常常需要通过缓存数据库中的数据来实现应用的高性能和高并发。

### 缓存特征
* 命中率：`命中率=返回正确结果数/请求缓存次数`
* 最大空间：可支持缓存数据所占空间的最大值，一旦元素数量超过这个值，将会触发缓存淘汰策略。
* 淘汰策略：如FIFO、LRU、LFU等。

### 缓存分类（按缓存与应用的耦合度）
* 本地缓存(local cache)：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费,而且，不同节点间可能存在数据不一致问题，使用时需要考虑缓存数据的时效性。
* 分布式缓存(remote cache):指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。缺点就是请求会有网络开销。

### 本地缓存
### 分布式缓存
### 缓存更新


### Cache Aside Pattern(最常用)
即先更新数据库，再删除缓存
* 失效： 应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中
* 命中： 应用程序从cache中取数据，取到后返回
* 更新： 应用程序把数据存到数据库中，成功后，让缓存失效

#### 为什么不先更新数据库，再更新缓存
这种做法最大的问题就是**两个并发写操作可能会导致脏数据**。假设有两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存，这样就会造成数据库和缓存中的数据不一致。
#### 为什么不先删除缓存，再更新数据库
这种做法的问题就是**两个请求，一个读一个写可能会导致脏数据**。假设有两个并发操作，一个更新操作，一个查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据都出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老数据，导致缓存中的数据时脏的直到失效。
#### 先更新数据库，再删除缓存有没有可能导致问题
这种做法是最常用也是最推荐的，理论上也会存在问题。假设有两个请求，一个查询请求，一个更新请求。查询操作没有命中缓存，然后从数据库中查出老数据。此时一个并发的更新操作，更新操作在读操作之后更新了数据库中的数据并且删除缓存。然后查询操作再把老数据放到缓存中，导致缓存中有脏数据。

但是，这个case理论上会出现，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着一个写操作，读操作必须在写操作前读取数据，并且要晚于写操作更新缓存。而实际上数据库的写操作会比读操作慢得多，需要锁表，所有这些条件都具备的可能性不大。

### Read/Write Through Pattern
在Cache Aside模式中，我们的应用代码需要维护两个数据，一个是缓存，一个是数据库。所以，应用程序比较啰嗦。而Read/Write Throgh模式把更新数据库的操作由缓存代理，对于应用层来说，可以认为只有一个单一的存储，存储自己维护自己的cache。
#### Read Through
查询操作中更新缓存，也就是说，当缓存失效的时候（过期或者内存淘汰），Cache Aside是由调用方负责把数据加载到缓存，而Read Through则由缓存服务自己来加载，对调用方来说缓存是透明的。
#### Write Through
当有数据需要更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库。

### Write Behind Cache Pattern

### 本地缓存 map
* 本地缓存非常高效，从分布式缓存取一次数据消耗的时间可以从本地缓存取几千几万甚至百万次
* 本地缓存在集群环境下存在不同节点数据不一致问题，因此，使用时需要考虑缓存的时效性，以及缓存数据对不一致的敏感程度

#### 缓存时效性
* 不同场景对同一份数据的时效性有差异，比如商品库存，在页面展示是否可以购买时可以有短暂的缓存，但是订单提交时必须是实时的数据
* 不同数据时效性不一样，比如商品属性时效性要求较低，商品价格和库存的时效性要求就比较高。

#### 本地缓存+分布式缓存构建高性能网站
* 使用本地缓存做一级缓存，减少分布式缓存的访问量（网络IO带宽消耗和IO传输时间）
* 使用分布式缓存做二级缓存，减少集群环境下访问数据库的次数

## 参考链接
* <https://coolshell.cn/articles/17416.html>