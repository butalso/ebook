# Redis篇

## 什么是Redis
Redis(Remote Dictionary Server)是一个使用C语言编写，开源（BSD许可）的高性能非关系型（NOSQL）键值对数据库。\
Redis可以存储键和五种不同类型的值之间的映射，键的类型只能是字符串，值的类型可为：字符串、列表、哈希、集合、有序集合。\
与传统数据库不同的是，Redis中的数据是存在内存中的，因此，读写速度非常快。也正因为如此，redis被广泛用来做数据缓存。另外，Redis也经常用来做分布式锁。除此之外，Redis还支持事务、持久化、LUA脚本，集群。

## Redis优缺点
优点
* 性能高，能支持每秒超过100K的读写频率
* 数据结构丰富，支持 字符创、列表、哈希、集合、有序集合五种对象，同时，封装的SDS数据结构是二进制安全的
* 支持事务，Redis的所有操作都是原子性的
* 支持数据持久化，可采用AOF、RDB两种持久化方式
* 其他特性： publish/subscribe，lua脚本等

缺点
* 由于是内存数据库，所以，单台机器，存储的数据量受到机器本身内存大小限制。虽然redis本身有key过期策略和内存淘汰策略，但是还是需要提前预估和节约内存。如果内存增长过快，最好定期删除数据

## Redis过期策略
* 定时删除：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
* 惰性删除：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，造成内存泄漏。
* 定期删除：定时删除和惰性删除折中方案。难点在于确定执行频率和时长。执行过于频繁和执行时间过长，退化成定时删除。反之，退化成惰性删除。

Redis采用惰性删除+定期删除

## 内存淘汰
Redis内存淘汰策略是指在Redis可用于缓存的内存不足时，怎么处理新写入且需要申请额外空间的数据。Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时需要申请额外空间的数据，而过期策略用于处理过期的缓存数据。

### 全局键空间选择性移除
* noeviction（默认策略）: 对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
* allkeys-lru： 从所有key中使用LRU算法进行淘汰
* allkeys-random： 从所有keys中随机淘汰

### 设置过期时间的键空间选择性移除
* volatile-lru： 从设置了过期时间的keys中使用LRU算法进行淘汰
* volatile-random： 从设置了过期时间的key中随机淘汰
* volatile-ttl： 在设置了过期时间的keys中，根据keys的过期时间进行淘汰，越早过期的越优先被淘汰

当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noevication一样返回错误。

## Redis为什么这么快
* 纯内存操作，不需要进行磁盘IO
* C语言实现，接近底层操作
* 高效的数据结构，同种对象在不同场景下都有可能用到不同数据结构，比如列表（压缩列表，链表），有序集合（压缩列表，跳表）
* 单线程的IO多路复用模型(6.0以前），单线程避免不必要上下文切换、抢锁，同时IO多路复用可以高效的处理多个网络连接请求。

## Redis 6.0为什么又引入了多线程
### 采用单线程
* IO多路复用，可同时监听多个网络请求
* 对于Redis来说，基于内存的操作速度相当快，能够达到1秒处理100K个用户请求的并发。同时，如果100K的并发了还不能满足，可以采用Redis分片技术将请求交给不同的Redis服务器处理。
* 多线程模型虽然在某些方面表现优异，但是同时引入程序执行顺序的不确定性，不方便调试测试。
### 多线程
* Redis的多线程部分主要用来处理网络数据读写和协议解析，执行命令依然主要是单线程。
* 对一些大键值对的删除操作，增加了多线程命令，比如FLUSHDB ASYNC。

## Redis应用场景
* 分布式锁： Redis的SETNX命令，官方的RedLock实现
* 排行榜&计数器： Redis可以在内存中对数字进行快速递增或递减。集合和有序集合也能是我们能快速获取到top_k的数据。
* 热点数据、页面缓存：将热点数据放到内存中，设置内存最大使用量以及淘汰策略来保证缓存命中率；将整个页面加载到内存中，配合Redis持久化，即使实例重启，也能恢复到内存中
* 会话缓存、session共享：使用Redis来统一多台应用服务器的会话信息，当应用服务器不再存储会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及伸缩性
* 消息队列： Redis有列表、集合对象，操作起来和本地一样轻便。
* 发布&订阅

## Redis持久化机制
Redis提供了两种持久化机制：RDB（默认）和AOF
### RDB(Redis Database)
RDB是Redis默认的持久化方式。按照一定时间间隔将内存中的数据以快照的形式保存到硬盘中，生成数据文件dump.rdb。在持续化过程中，会先将数据写入到一个临时文件中，等持久化过程结束后，才会用临时文件替换上次持久化后的文件\
优点：
* 在数据集比较大时，一般都会比AOF启动效率更高

缺点：
* 数据安全性低，RDB持久化方式是定期执行，当Redis故障时，则从上次持久化到故障发生时的数据都会丢失。如果频繁执行的话，会占用大量的磁盘IO，影响性能。
  
### AOF(Append-only file)
AOF持久化方式是通过保存Redis服务器所执行写命令来记录数据库的状态。当服务器重启时，重新执行这些命令就能恢复到原来的状态。\
appendfsync选项：
* always： 服务器在每个事件循环中都会将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件。效率最低，数据最安全，最多丢失一个事件循环中所产生的命令事件
* everysec：服务器在每个事件循环中都会将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。效率足够快，并且出现故障只会丢失一秒钟的数据。
* no: 服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。效率最高，但是故障时会丢失上次同步AOF文件之后的所有写命令数据。

因为AOF采用追加的方式，所以文件会越来越大，很可能会对Redis服务器性能产生影响。当文件大到一定程度时，会触发AOF重写机制，默认触发条件是aof文件大于64M且比上次重写后的文件大一倍。\
AOF重写步骤：
1. 主进程fork出子进程，读取服务器当前状态，写到新的AOF文件
2. 重写期间，客户端的写命令会同时写到AOF缓冲区和重写缓冲区，AOF缓冲区的命令会按照策略保存到当前AOF文件。
3. 重写完成后，通知主进程，主进程将重写缓冲区的内容全部写入到新的AOF文件
4. 新的AOF文件改名，原子性覆盖现有的AOF文件

优点：
* 比RDB更新频率高，数据更全，rdb、aof两者方式都开启时，优先使用aof还原数据。

缺点：
* 比RDB文件更大，启动速度慢。

## 如何选择合适的持久化方式
* 一般来说，没有绝对安全的系统，如果对数据安全性要求很高，应该同时使用两种持久化功能。在这种情况下，当Redis重启时会优先加载AOF文件来恢复原始数据，因为通常情况下AOF文件保存的数据集要比RDB文件保存的数据要完整。
* 有些用户只采用AOF持久化的方式，但事实上，如果数据可以接受分钟级别的丢失，可以只采用RDB的方式。同时，从RDB中恢复数据集的速度也要比从AOF恢复的速度更快。
* 如果可接受数据只在服务器运行时才存在，也可以不采用任何持久化方式。

## Redis事务
### 事务的三个阶段
1. 事务开始multi
2. 命令入队
3. 事务执行exec

事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，则会把请求放入到队列中。

### ACID特性
#### 原子性
事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。
* Redis事务队列中的命令会要么全部执行，要么全部不执行。
* Redis不支持事务回滚，即执行过程事务队列中的某一个命令失败了，整个事务也会继续执行下去。（为了保持简单高效，而且Redis事务执行时错误通常都是编程时出现的）
#### 一致性
事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。
1. 命令入队错误，拒绝执行
2. 命令执行错误，不会对数据库做出修改
3. 服务器停机：如果redis运行在无持久化的内存模式下，则重启后数据库是空白的，符合一致性；如果redis运行在RDB模式下，在执行事务过程时，Redis不会中断事务去执行保存RDB的工作，因此从RDB还原后的数据库符合一致性；如果redis运行在AOF模式下，可能有部分事务的内容会被写入到AOF文件中，这是用工具把AOF中事务执行部分成功的指令移除，则从AOF还原后的数据也符合一致性。
### 隔离性
事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。\
Redis采用单线程的方式执行命令，并且执行事务期间不会对事务进行中断，所以，具备隔离性
### 持久性
事务的持久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。\
* 当redis运行在AOF持久化模式下并且appendfsync选项的值为always，则事务具有持久性。
* 不论redis运行在什么模式下，在一个事务最后加上SAVE命令，总是可以保证事物的持久性。

综上，Redis的事务总是具有ACID中的原子性、一致性、隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。

## Redis高可用性
### 复制
#### 完整重同步
#### 部分重同步
### 哨兵
由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

## Redis与memcached对比
Redis作者对两种基于内存的数据存储系统进行的比较：
* 性能：由于redis只使用单核，而memcached可以使用多核，所以平均每一个核上redis在存储小数据时比memcached性能更高。而在100k以上的数据中，memcached性能要高于redis，虽然redis最近也在存储大数据的性能上进行优化，但是比起memcached，还是稍有逊色。
* 内存使用效率：使用简单的key-value存储的话，memcached的内存利用率更高，而如果redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memcached。另外，memcached使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而redis使用现场申请内存的方式来存储数据，不会剔除任何非临时数据。
* redis支持服务器端的数据操作：redis相比memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么redis会是不错的选择。

另外：
* Redis支持数据的备份，即master-slave模式的数据备份。
* Redis支持数据的持久化，


## 使用Redis需要注意的问题
* 要进行master-slave配置，出现服务故障时可以支持切换
* 在master侧禁用数据持久化，只需在slave上配置数据持久化
* 当Redis物理内存s
