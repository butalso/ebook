# Redis篇

## 什么是Redis
Redis(Remote Dictionary Server)是一个使用C语言编写，开源（BSD许可）的高性能非关系型（NOSQL）键值对数据库。

Redis可以存储键和五种不同类型的值之间的映射，键的类型只能是字符串，值的类型可为：字符串、列表、哈希、集合、有序集合。

与传统数据库不同的是，Redis中的数据是存在内存中的，因此，读写速度非常快。也正因为如此，redis被广泛用来做数据缓存。另外，Redis也经常用来做分布式锁。除此之外，Redis还支持事务、持久化、LUA脚本，集群。

## Redis优缺点
优点
* 性能高，能支持每秒超过100K的读写频率
* 数据结构丰富，支持 字符创、列表、哈希、集合、有序集合五种对象，同时，封装的SDS数据结构是二进制安全的
* 支持事务，Redis的所有操作都是原子性的
* 支持数据持久化，可采用AOF、RDB两种持久化方式
* 其他特性： publish/subscribe，lua脚本等

缺点
* 由于是内存数据库，所以，单台机器，存储的数据量受到机器本身内存大小限制。虽然redis本身有key过期策略和内存淘汰策略，但是还是需要提前预估和节约内存。如果内存增长过快，最好定期删除数据

## Redis内存回收机制
Redis内存回收机制主要分为国企删除策略和内存淘汰策略。值得一提的是，Redis还采用了**引用计数算法**来跟踪对象的使用情况。尽管共享对象可以节约内存，但是权衡CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。
### Redis过期策略
* 定时删除：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
* 惰性删除：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，造成内存泄漏。
* 定期删除：定时删除和惰性删除折中方案。难点在于确定执行频率和时长。执行过于频繁和执行时间过长，退化成定时删除。反之，退化成惰性删除。

Redis采用惰性删除+定期删除
### 内存淘汰
Redis内存淘汰策略是指在Redis使用内存达到maxmemory设置时，怎么处理新写入且需要申请额外空间的数据。Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时需要申请额外空间的数据，而过期策略用于处理过期的缓存数据。

#### 全局键空间选择性移除
* noeviction（默认策略）: 对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
* allkeys-lru： 从所有key中使用LRU算法进行淘汰
* allkeys-random： 从所有keys中随机淘汰
#### 设置过期时间的键空间选择性移除
* volatile-lru： 从设置了过期时间的keys中使用LRU算法进行淘汰
* volatile-random： 从设置了过期时间的key中随机淘汰
* volatile-ttl： 在设置了过期时间的keys中，根据keys的过期时间进行淘汰，越早过期的越优先被淘汰

当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noevication一样返回错误。

## Redis批处理pipeline
### 为什么使用pipeline
Redis的工作过程是基于请求/响应模式的，所以客户端发出一个请求发出后，要等到这个请求被服务端响应回来才能继续发出下一个请求，这样要是有大批的请求需要处理，不仅要来回好多次，而且这好几次都是I/O请求，所以Pipeline应运而生了，它允许客户端一次性发送多条命令，不需要等待上一条命令的处理结果，最后所有命令一起处理完返回就好了。


## Redis为什么这么快
* 纯内存操作，不需要进行磁盘IO
* C语言实现，接近底层操作
* 高效的数据结构，同种对象在不同场景下都有可能用到不同数据结构，比如列表（压缩列表，链表），有序集合（压缩列表，跳表）
* 单线程的IO多路复用模型(6.0以前），单线程避免不必要上下文切换、抢锁，同时IO多路复用可以高效的处理多个网络连接请求。

## Redis 6.0为什么又引入了多线程
### 采用单线程
* IO多路复用，可同时监听多个网络请求
* 对于Redis来说，基于内存的操作速度相当快，能够达到1秒处理100K个用户请求的并发。同时，如果100K的并发了还不能满足，可以采用Redis分片技术将请求交给不同的Redis服务器处理。
* 多线程模型虽然在某些方面表现优异，但是同时引入程序执行顺序的不确定性，不方便调试测试。
### 多线程
* Redis的多线程部分主要用来处理网络数据读写和协议解析，执行命令依然主要是单线程。
* 对一些大键值对的删除操作，增加了多线程命令，比如FLUSHDB ASYNC。

## Redis应用场景
* 分布式锁： Redis的SETNX命令，官方的RedLock实现
* 排行榜&计数器： Redis可以在内存中对数字进行快速递增或递减。集合和有序集合也能是我们能快速获取到top_k的数据。
* 热点数据、页面缓存：将热点数据放到内存中，设置内存最大使用量以及淘汰策略来保证缓存命中率；将整个页面加载到内存中，配合Redis持久化，即使实例重启，也能恢复到内存中
* 会话缓存、session共享：使用Redis来统一多台应用服务器的会话信息，当应用服务器不再存储会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及伸缩性
* 消息队列： Redis有列表、集合对象，操作起来和本地一样轻便。
* 发布&订阅

## Redis持久化机制
Redis提供了两种持久化机制：RDB（默认）和AOF
### RDB(Redis Database)
RDB是Redis默认的持久化方式。按照一定时间间隔将内存中的数据以快照的形式保存到硬盘中，生成数据文件dump.rdb。在持续化过程中，会先将数据写入到一个临时文件中，等持久化过程结束后，才会用临时文件替换上次持久化后的文件\
优点：
* 在数据集比较大时，一般都会比AOF启动效率更高

缺点：
* 数据安全性低，RDB持久化方式是定期执行，当Redis故障时，则从上次持久化到故障发生时的数据都会丢失。如果频繁执行的话，会占用大量的磁盘IO，影响性能。
  
### AOF(Append-only file)
AOF持久化方式是通过保存Redis服务器所执行写命令来记录数据库的状态。当服务器重启时，重新执行这些命令就能恢复到原来的状态。\
appendfsync选项：
* always： 服务器在每个事件循环中都会将aof_buf缓冲区中的所有内容写入到AOF文件，并且同步AOF文件。效率最低，数据最安全，最多丢失一个事件循环中所产生的命令事件
* everysec：服务器在每个事件循环中都会将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。效率足够快，并且出现故障只会丢失一秒钟的数据。
* no: 服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。效率最高，但是故障时会丢失上次同步AOF文件之后的所有写命令数据。

因为AOF采用追加的方式，所以文件会越来越大，很可能会对Redis服务器性能产生影响。当文件大到一定程度时，会触发AOF重写机制，默认触发条件是aof文件大于64M且比上次重写后的文件大一倍。\
AOF重写步骤：
1. 主进程fork出子进程，读取服务器当前状态，写到新的AOF文件
2. 重写期间，客户端的写命令会同时写到AOF缓冲区和重写缓冲区，AOF缓冲区的命令会按照策略保存到当前AOF文件。
3. 重写完成后，通知主进程，主进程将重写缓冲区的内容全部写入到新的AOF文件
4. 新的AOF文件改名，原子性覆盖现有的AOF文件

优点：
* 比RDB更新频率高，数据更全，rdb、aof两者方式都开启时，优先使用aof还原数据。

缺点：
* 比RDB文件更大，启动速度慢。

## 如何选择合适的持久化方式
* 一般来说，没有绝对安全的系统，如果对数据安全性要求很高，应该同时使用两种持久化功能。在这种情况下，当Redis重启时会优先加载AOF文件来恢复原始数据，因为通常情况下AOF文件保存的数据集要比RDB文件保存的数据要完整。
* 有些用户只采用AOF持久化的方式，但事实上，如果数据可以接受分钟级别的丢失，可以只采用RDB的方式。同时，从RDB中恢复数据集的速度也要比从AOF恢复的速度更快。
* 如果可接受数据只在服务器运行时才存在，也可以不采用任何持久化方式。

## Redis事务
### 事务的三个阶段
1. 事务开始multi
2. 命令入队
3. 事务执行exec

事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，则会把请求放入到队列中。

### ACID特性
#### 原子性
事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。
* Redis事务队列中的命令会要么全部执行，要么全部不执行。
* Redis不支持事务回滚，即执行过程事务队列中的某一个命令失败了，整个事务也会继续执行下去。（为了保持简单高效，而且Redis事务执行时错误通常都是编程时出现的）
#### 一致性
事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。
1. 命令入队错误，拒绝执行
2. 命令执行错误，不会对数据库做出修改
3. 服务器停机：如果redis运行在无持久化的内存模式下，则重启后数据库是空白的，符合一致性；如果redis运行在RDB模式下，在执行事务过程时，Redis不会中断事务去执行保存RDB的工作，因此从RDB还原后的数据库符合一致性；如果redis运行在AOF模式下，可能有部分事务的内容会被写入到AOF文件中，这是用工具把AOF中事务执行部分成功的指令移除，则从AOF还原后的数据也符合一致性。
### 隔离性
事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。\
Redis采用单线程的方式执行命令，并且执行事务期间不会对事务进行中断，所以，具备隔离性
### 持久性
事务的持久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。\
* 当redis运行在AOF持久化模式下并且appendfsync选项的值为always，则事务具有持久性。
* 不论redis运行在什么模式下，在一个事务最后加上SAVE命令，总是可以保证事物的持久性。

综上，Redis的事务总是具有ACID中的原子性、一致性、隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有持久性。

## 如何使用Redis支持高并发和高可用性
### 如果Redis要支撑超过100K+的并发，应该怎么做
单机Redis一般能支持的QPS就是100K，要支持100K+的并发，可以通过主从架构来做读写分离。还有，可以通过集群分区，将请求分配到多个Redis节点来进行处理。
### 复制（主从架构）
#### 复制偏移量
* 执行复制的双方，主服务器和从服务器会分别维护一个复制偏移量
* 主服务器每次向从服务器传播N个字节的数据时，就会将自己的复制偏移量加上N
* 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量值加上N
#### 复制挤压缓冲区
复制积压缓冲区是由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB。
#### 服务器运行ID
#### PSYNC命令实现
* 如果从服务器没有执行过复制某个主服务器的操作，或者之前执行过`SLAVEOF no one`命令，则主服务器在开始一次新的复制时将向主服务器发送`PSNC ? -1`命令，主动请求主服务器执行完整重同步。
* 从服务器向主服务器发送`PSNC <runid> <offset>`，如果runid是主服务器的运行ID，并且复制偏移量offset之后的数据仍然存在于主服务器的复制积压缓冲区里面，则主服务器向从服务器返回`+CONTINUE`表示执行部分重同步。否则，主服务器将在后台执行`BGSAVE`命令，向从服务器返回`FULLRESYNC <runid> <offset>`,表示执行完整重同步。

### 什么情况下Redis不可用？不可用后果会是？
redis不可用可以是：
* redis进程挂掉了
* redis进程所在的机器挂掉了

redis不可用，则用于支撑高并发高性能的缓存不可用了，会有大量的请求达到db层，击穿存储。
### redis如何实现高可用？
Redis通过一个或多个哨兵实例组成的哨兵系统，可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。
#### 下线检测
哨兵会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器，从服务器，其他sentinel）发送ping命令，通过回复来判断实例是否在线。如果在有限的时间内得不到有效恢复，则认为该实例主观下线。如果哨兵将一个主服务器判断为主观下线后，则为了确认该主服务器是否真的下线了，会向监视这一主服务器的其他哨兵询问，但收到足够的数量的已下线判断之后，该哨兵就会认为主服务器为客观下线。值得一提的是，不同的哨兵判断客观下线的条件可以不同。
#### 故障转移
当一个主服务器被哨兵判断为客观下线时，监视这个下线主服务器的各个哨兵就会进行协商，通过**raft算法**选举出一个领头哨兵，并由领头哨兵对下线主服务器执行故障转移操作。

## Redis高扩展
Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。
#### Redis集群分片方式
Redis集群采用虚拟哈希槽分区，所有的键根据哈希函数映射到0-16383整数槽内，计算公式：`slot = CRC16(key) & 16383`。每个节点负责维护一部分槽及槽所映射的键值数据。

特点：
* 解耦数据和节点之间的关系，简化了节点扩容和收缩的难度。
* 节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据
* 支持节点、槽和键之间的映射查询，用于数据路由，在线集群伸缩等场景。

#### 集群扩容&缩容
当一个 Redis 新节点运行并加入现有集群后，我们需要为其迁移槽和数据。首先要为新节点指定槽的迁移计划，确保迁移后每个节点负责相似数量的槽，从而保证这些节点的数据均匀; 当一个Redis节点下线时，我们需要将下线节点负责的槽迁移到其他节点，保证整个集群槽节点映射的完整性，同时还要通知集群内其他节点忘记下线节点。
##### slot重新分片
Redis集群的重新分片操作是由Redis的集群管理软件redis-trib负责执行的，Redis提供了进行重新分片所需的所有命令，而
redis-trib则通过向源节点和目标节点发送命令来进行重新分片操作。
1. redis-trib对目标节点发送`CLUSTER SETSLOT <slot> IMPORTING <source_id>`命令，让目标节点准备好从源节点导入属于槽slot的键值对。
2. redis-trib对源节点发送`CLUSTER SETSLOT <slot> MIGRATING <target_id>`命令，让源节点准备好将属于槽slot的键值对迁移至目标节点。
3. redis-trib向源节点发送`CLUSTER GETKEYSINSLOT <slot> <count>`命令，获得最多count个属于槽slot的键值对的键名。
4. 对于步骤3获得的每个键名，redis-trib都向源节点发送一个`MIGRATE <target_ip> <target_port> <key_name> 0 <timeout>`命令，将被选中的键原子地从源节点迁移至目标节点。
5. 重复执行步骤3和步骤4，直到源节点保存的所有属于槽slot的键值对都被迁移至目标节点为止。
6. redis-trib向集群中的任意一个节点发送`CLUSTER SETSLOT <slot> NODE <target_id>`命令，将槽slot指派给目标节点
，这一指派信息会通过消息发送至整个集群，最终集群中的所有节点都会知道槽slot已经指派给了目标节点。

#### 客户端路由
1. 客户端根据本地 slot 缓存发送命令到源节点，如果存在键对应则直接执行并返回结果给客户端。
2. 如果节点返回 MOVED 错误，更新本地的 slot 到 Redis 节点的映射关系，然后重新发起请求。
3. 如果数据正在迁移中，节点会回复 ASK 重定向异常。

##### MOVED错误和ASK错误区别：
ASK 和 MOVED 虽然都是对客户端的重定向控制，但是有着本质区别。ASK 重定向说明集群正在进行 slot 数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新 slot 到 Redis 节点的映射缓存。但是 MOVED 重定向说明键对应的槽已经明确指定到新的节点，因此需要更新 slot 到 Redis 节点的映射缓存。

## 一个字符串类型的值能存储最大容量是多少
512MB

## Redis与memcached对比
Redis作者对两种基于内存的数据存储系统进行的比较：
* 性能：由于redis只使用单核，而memcached可以使用多核，所以平均每一个核上redis在存储小数据时比memcached性能更高。而在100k以上的数据中，memcached性能要高于redis，虽然redis最近也在存储大数据的性能上进行优化，但是比起memcached，还是稍有逊色。
* 内存使用效率：使用简单的key-value存储的话，memcached的内存利用率更高，而如果redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memcached。另外，memcached使用预分配的内存池的方式，带来一定程度的空间浪费 并且在内存仍然有很大空间时，新的数据也可能会被剔除，而redis使用现场申请内存的方式来存储数据，不会剔除任何非临时数据。
* redis支持服务器端的数据操作：redis相比memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么redis会是不错的选择。

另外：
* Redis支持数据的备份，即master-slave模式的数据备份。
* Redis支持数据的持久化，


## 使用Redis需要注意的问题
* 大量的key设置同一过期时间，则redis可能会在那个时间点出现短暂卡顿现象。如果可以的话，将过期时间加上一个随机值，分散内存回收操作。

## 参考链接
<https://juejin.im/post/5cf7c811f265da1b7a4b6368>