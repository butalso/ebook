# 操作系统-IO篇

## 概念说明
* 用户空间与内核空间
* 进程切换
* 进程阻塞
* 文件描述符
* 缓存IO
* 自缓存应用程序
* 直接IO

### 用户空间与内核空间
现代操作系统都采用虚拟存储器，对于32位操作系统而言，寻址空间（虚拟存储空间）为4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核安全，操作系统将虚拟存储空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，地址最高的1GB字节（从虚拟地址0xC0000000到0xFFFFFFFF)供内核使用，成为内核空间，较低的3GB字节（从虚拟地址0x00000000到0xBFFFFFFF)供各个进程使用，成为用户空间。
### 进程切换
为了控制进程的执行，内核必须要有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下执行的，是与内核紧密相关的。
从一个进程的运行切换到另一个进程，需要
1. 保存处理机上下文，包括程序计数器和寄存器
2. 更新PCB信息
3. 把进程PCB移入相应的队列，如就绪、阻塞队列
4. 选择另一个进程的执行，并更新PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

总而言之就是很耗资源
### 进程的阻塞
正在执行的进程，由于期待某些事件的发生，如请求系统资源失败、等待某种操作的完成，新数据尚未到达等，则由系统执行阻塞原语，从运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程，才能将其转为阻塞态。当进程进入阻塞态时，是不占用CPU资源的。
### 文件描述符
在Linux系统中，一切都是文件。文件描述符就是当程序打开一个现有文件或者创建一个新文件时，内核向进程返回值。

### 缓存IO
缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。
* 读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。
* 写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令
#### 优点
* 在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；
* 可以减少读写盘的次数，从而提高性能。\
当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被放到页缓存中，那么就需要先将数据从磁盘读到页缓存中。对于写操作来说，应用程序也会将数据写到页缓存中去，数据是否立即写到磁盘上去取决于应用程序所采用的写机制：如果用户采用的是同步写机制，那么数据会立即写到磁盘上去，应用程序一直等待到数据写完为止；如果用户才用的是延迟写机制，那么应用程序不需要等待数据全部被写回到磁盘，数据只要写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期将放在页缓存中的数据刷到磁盘上去。与异步写机制不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候会返回给应用程序的。所以延迟写机制本身存在丢数据的风险，而异步写机制则不会。
#### 缺点
* 在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。
### 自缓存应用程序
对于某些应用程序来说，它会有自己的数据缓存机制，比如，它会将数据缓存在应用程序的地址空间，这类应用程序完全不需要使用操作系统内核中的告诉缓冲存储器，这类应用程序就被称作自缓存应用程序，比如数据库管理系统。自缓存应用需要对操作的数据语义了如指掌，所以它可以采用更高效的缓存替换算法。
### 直接IO
通常来说，直接IO需要跟异步IO结合起来使用
#### 优点
* 减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，降低了对文件读写所带来的CPU使用和内存带宽的占用。
#### 缺点
* 设置直接IO的开销非常大
* 读操作: 直接IO的读操作会造成磁盘同步读。这可能会导致进程需要较长时间才能执行完。
* 写操作：直接IO需要write()系统调用同步执行，也可能会导致应用程序关闭缓慢。

## IO模式
当一个read操作发生时，需要经历两个阶段
1. 等待数据准备
2. 将数据从内核拷贝到进程中

因此,Linux系统产生了以下五种IO模式
1. 阻塞IO
2. 非阻塞IO
3. IO多路复用
4. 信号驱动IO
5. 异步IO

## IO多路复用
### 阻塞IO
对于阻塞的IO来说，当调用read、write执行操作时，如果数据还没准备好，那么该线程就会被挂起，直到数据准备好。\
对于服务器来说，假如它需要处理1000个连接，但这1000个连接又只有很少连接是忙碌的，则这1000个线程大部分时间是处于阻塞状态的。由于CPU的核数或超线程数一般较小，那么每个线程分配得到的时间片也就比较少，线程切换频繁。这样子是有问题的
* 线程是有内存开销的，1个线程可能需要512K存放栈，那么1000个线程就需要512M内存。
* 线程切换是需要消耗CPU时间的。当大量时间花在上下文切换的时候，分配给真正的操作的CPU时间就要少很多。

### IO多路复用（事件驱动）
多路复用在通信上指的是在一个信道上传输多路信号或数据流的技术。\
IO多路复用指的是通过某种机制，监听多个文件描述符（socket)，当其中任意一个文件描述符处于就绪状态时，能够通知程序进行相应的读写操作。

### 同步、异步、阻塞、非阻塞
#### 同步&异步
同步和异步关注的是**消息通信机制**，所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。而异步则是在调用发出后，调用直接就返回了。
#### 阻塞&非阻塞
阻塞和非阻塞关注的是程序在等待调用结果时的状态。阻塞指在调用结果返回前，当前线程会被挂起，调用线程只有得到结果之后才会返回。非阻塞指在不能立刻得到结果之前，该调用不会阻塞当前线程。\
以小明下载文件为例：
* 同步阻塞：小明一直盯着下载进度条，知道100%下载完成
* 同步非阻塞：小明点击下载后就玩手机去了，不过每隔一段时间会过来check下载是否完成
* 异步阻塞：小明有个下载完成通知的软件，在下载完成后会“叮”的一声通知小明下载完成，不过小明一直傻傻的等待“叮”的声音
* 异步非阻塞：仍然是那个下载完成会“叮”的一声通知的软件，不过小明提交下载任务后就去做别的事情去了，当听到“叮”的声音就知道下载完成了。
